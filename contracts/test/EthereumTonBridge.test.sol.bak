// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import {Test, console2} from "forge-std/Test.sol";
import {EthereumTonBridge} from "../src/EthereumTonBridge.sol";
import {SecurityUtils} from "../src/SecurityUtils.sol";
import {IERC20} from "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import {ERC20Mock} from "openzeppelin-contracts/contracts/mocks/token/ERC20Mock.sol";

contract EthereumTonBridgeTest is Test {
    EthereumTonBridge public bridge;
    SecurityUtils public securityUtils;
    ERC20Mock public mockToken;
    
    address public owner;
    address public user1;
    address public user2;
    address public relayer1;
    address public relayer2;
    address public unauthorizedRelayer;
    
    bytes32 public testSecret;
    bytes32 public testHashlock;
    bytes32 public orderId;
    string public tonRecipient;
    
    event TonEscrowCreated(
        bytes32 indexed orderId,
        address indexed sender,
        string tonRecipient,
        uint256 amount,
        bytes32 hashlock,
        uint256 timelock,
        address token
    );
    
    event TonEscrowFulfilled(
        bytes32 indexed orderId,
        bytes32 secret,
        address fulfiller
    );
    
    event TonEscrowRefunded(
        bytes32 indexed orderId,
        address refunder
    );
    
    event TonMessageVerified(
        bytes32 indexed messageHash,
        address indexed relayer,
        bool verified
    );
    
    event RelayerAdded(address indexed relayer);
    event RelayerRemoved(address indexed relayer);
    
    function setUp() public {
        owner = makeAddr("owner");
        user1 = makeAddr("user1");
        user2 = makeAddr("user2");
        relayer1 = makeAddr("relayer1");
        relayer2 = makeAddr("relayer2");
        unauthorizedRelayer = makeAddr("unauthorizedRelayer");
        
        vm.prank(owner);
        bridge = new EthereumTonBridge(owner);
        
        vm.prank(owner);
        securityUtils = new SecurityUtils();
        
        mockToken = new ERC20Mock();
        
        // Generate test data
        testSecret = keccak256("test_secret_123");
        testHashlock = keccak256(abi.encodePacked(testSecret));
        orderId = keccak256("test_order_123");
        tonRecipient = "EQD4FPq-PRDieyQKkizFTRtSDyucUIqrj0v_zXJmqaDp6_0t";
        
        // Add relayers
        vm.prank(owner);
        bridge.addRelayer(relayer1);
        
        vm.prank(owner);
        bridge.addRelayer(relayer2);
        
        // Fund users
        vm.deal(user1, 100 ether);
        vm.deal(user2, 100 ether);
        
        // Mint tokens
        mockToken.mint(user1, 1000e18);
        mockToken.mint(user2, 1000e18);
    }
    
    // Test relayer management
    function testAddRelayer() public {
        vm.prank(owner);
        bridge.addRelayer(unauthorizedRelayer);
        
        assertTrue(bridge.authorizedRelayers(unauthorizedRelayer));
    }
    
    function testAddRelayerNotOwner() public {
        vm.prank(user1);
        vm.expectRevert();
        bridge.addRelayer(unauthorizedRelayer);
    }
    
    function testAddRelayerZeroAddress() public {
        vm.prank(owner);
        vm.expectRevert("Invalid relayer address");
        bridge.addRelayer(address(0));
    }
    
    function testAddRelayerAlreadyExists() public {
        vm.prank(owner);
        vm.expectRevert("Relayer already exists");
        bridge.addRelayer(relayer1);
    }
    
    function testRemoveRelayer() public {
        vm.prank(owner);
        bridge.removeRelayer(relayer1);
        
        assertFalse(bridge.authorizedRelayers(relayer1));
    }
    
    function testRemoveRelayerNotOwner() public {
        vm.prank(user1);
        vm.expectRevert();
        bridge.removeRelayer(relayer1);
    }
    
    function testRemoveRelayerNotExists() public {
        vm.prank(owner);
        vm.expectRevert("Relayer does not exist");
        bridge.removeRelayer(unauthorizedRelayer);
    }
    
    function testRelayerEvents() public {
        vm.prank(owner);
        vm.expectEmit(true, true, false, true);
        emit RelayerAdded(unauthorizedRelayer);
        bridge.addRelayer(unauthorizedRelayer);
        
        vm.prank(owner);
        vm.expectEmit(true, true, false, true);
        emit RelayerRemoved(unauthorizedRelayer);
        bridge.removeRelayer(unauthorizedRelayer);
    }
    
    // Test ETH escrow creation
    function testCreateTonEscrowETH() public {
        uint256 amount = 1 ether;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.prank(user1);
        bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0) // ETH
        );
        
        EthereumTonBridge.EscrowOrder memory order = bridge.orders(orderId);
        assertEq(order.sender, user1);
        assertEq(order.tonRecipient, tonRecipient);
        assertEq(order.amount, amount);
        assertEq(order.token, address(0));
        assertEq(order.hashlock, testHashlock);
        assertEq(order.timelock, timelock);
        assertEq(uint256(order.status), 0); // Pending
    }
    
    function testCreateTonEscrowETHInsufficientValue() public {
        uint256 amount = 1 ether;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.prank(user1);
        vm.expectRevert("Insufficient ETH sent");
        bridge.createTonEscrow{value: 0.5 ether}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        );
    }
    
    function testCreateTonEscrowETHInvalidTimelock() public {
        uint256 amount = 1 ether;
        uint256 shortTimelock = block.timestamp + 30 minutes;
        
        vm.prank(user1);
        vm.expectRevert("Invalid timelock");
        bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            shortTimelock,
            address(0)
        );
    }
    
    function testCreateTonEscrowETHEvent() public {
        uint256 amount = 1 ether;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.prank(user1);
        vm.expectEmit(true, true, false, true);
        emit TonEscrowCreated(
            orderId,
            user1,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        );
        bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        );
    }
    
    // Test token escrow creation
    function testCreateTonEscrowToken() public {
        uint256 amount = 100e18;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.startPrank(user1);
        mockToken.approve(address(bridge), amount);
        bridge.createTonEscrow(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(mockToken)
        );
        vm.stopPrank();
        
        EthereumTonBridge.EscrowOrder memory order = bridge.orders(orderId);
        assertEq(order.sender, user1);
        assertEq(order.token, address(mockToken));
        assertEq(order.amount, amount);
    }
    
    function testCreateTonEscrowTokenInsufficientAllowance() public {
        uint256 amount = 100e18;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.startPrank(user1);
        mockToken.approve(address(bridge), 50e18); // Insufficient allowance
        vm.expectRevert("ERC20: insufficient allowance");
        bridge.createTonEscrow(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(mockToken)
        );
        vm.stopPrank();
    }
    
    // Test escrow fulfillment
    function testFulfillFromTon() public {
        // Create escrow first
        uint256 amount = 1 ether;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.prank(user1);
        bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        );
        
        // Fulfill from TON
        vm.prank(relayer1);
        bridge.fulfillFromTon(
            orderId,
            testSecret,
            user2
        );
        
        EthereumTonBridge.EscrowOrder memory order = bridge.orders(orderId);
        assertEq(uint256(order.status), 1); // Fulfilled
        assertEq(order.secret, testSecret);
    }
    
    function testFulfillFromTonNotRelayer() public {
        vm.prank(user1);
        vm.expectRevert("Not authorized relayer");
        bridge.fulfillFromTon(
            orderId,
            testSecret,
            user2
        );
    }
    
    function testFulfillFromTonOrderNotExists() public {
        vm.prank(relayer1);
        vm.expectRevert("Order does not exist");
        bridge.fulfillFromTon(
            orderId,
            testSecret,
            user2
        );
    }
    
    function testFulfillFromTonInvalidSecret() public {
        // Create escrow first
        uint256 amount = 1 ether;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.prank(user1);
        bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        );
        
        // Try to fulfill with wrong secret
        bytes32 wrongSecret = keccak256("wrong_secret");
        vm.prank(relayer1);
        vm.expectRevert("Invalid secret");
        bridge.fulfillFromTon(
            orderId,
            wrongSecret,
            user2
        );
    }
    
    function testFulfillFromTonAlreadyFulfilled() public {
        // Create escrow first
        uint256 amount = 1 ether;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.prank(user1);
        bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        );
        
        // Fulfill first time
        vm.prank(relayer1);
        bridge.fulfillFromTon(
            orderId,
            testSecret,
            user2
        );
        
        // Try to fulfill again
        vm.prank(relayer2);
        vm.expectRevert("Order not pending");
        bridge.fulfillFromTon(
            orderId,
            testSecret,
            user2
        );
    }
    
    function testFulfillFromTonEvent() public {
        // Create escrow first
        uint256 amount = 1 ether;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.prank(user1);
        bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        );
        
        // Fulfill
        vm.prank(relayer1);
        vm.expectEmit(true, false, false, true);
        emit TonEscrowFulfilled(orderId, testSecret, relayer1);
        bridge.fulfillFromTon(
            orderId,
            testSecret,
            user2
        );
    }
    
    // Test escrow refund
    function testRefundTonEscrow() public {
        // Create escrow first
        uint256 amount = 1 ether;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.prank(user1);
        bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        );
        
        // Fast forward past timelock
        vm.warp(block.timestamp + 3 hours);
        
        // Refund
        vm.prank(user1);
        bridge.refundTonEscrow(orderId);
        
        EthereumTonBridge.EscrowOrder memory order = bridge.orders(orderId);
        assertEq(uint256(order.status), 2); // Refunded
    }
    
    function testRefundTonEscrowNotOwner() public {
        // Create escrow first
        uint256 amount = 1 ether;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.prank(user1);
        bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        );
        
        // Try to refund as non-owner
        vm.prank(user2);
        vm.expectRevert("Not order owner");
        bridge.refundTonEscrow(orderId);
    }
    
    function testRefundTonEscrowNotExpired() public {
        // Create escrow first
        uint256 amount = 1 ether;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.prank(user1);
        bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        );
        
        // Try to refund before expiry
        vm.prank(user1);
        vm.expectRevert("Timelock not expired");
        bridge.refundTonEscrow(orderId);
    }
    
    function testRefundTonEscrowAlreadyFulfilled() public {
        // Create escrow first
        uint256 amount = 1 ether;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.prank(user1);
        bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        );
        
        // Fulfill
        vm.prank(relayer1);
        bridge.fulfillFromTon(
            orderId,
            testSecret,
            user2
        );
        
        // Try to refund fulfilled escrow
        vm.prank(user1);
        vm.expectRevert("Order not pending");
        bridge.refundTonEscrow(orderId);
    }
    
    function testRefundTonEscrowEvent() public {
        // Create escrow first
        uint256 amount = 1 ether;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.prank(user1);
        bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        );
        
        // Fast forward past timelock
        vm.warp(block.timestamp + 3 hours);
        
        // Refund
        vm.prank(user1);
        vm.expectEmit(true, false, false, true);
        emit TonEscrowRefunded(orderId, user1);
        bridge.refundTonEscrow(orderId);
    }
    
    // Test message verification
    function testVerifyTonMessage() public {
        bytes32 messageHash = keccak256("test_message");
        bytes32 messageId = keccak256("message_id");
        
        vm.prank(relayer1);
        bridge.verifyTonMessage(
            messageHash,
            messageId,
            user1,
            tonRecipient,
            1 ether,
            testHashlock,
            block.timestamp + 2 hours
        );
        
        EthereumTonBridge.TonMessage memory message = bridge.tonMessages(messageId);
        assertEq(message.messageId, messageId);
        assertEq(message.sourceAddress, user1);
        assertEq(message.destAddress, tonRecipient);
        assertEq(message.amount, 1 ether);
        assertEq(message.hashlock, testHashlock);
        assertTrue(message.verified);
    }
    
    function testVerifyTonMessageNotRelayer() public {
        bytes32 messageHash = keccak256("test_message");
        bytes32 messageId = keccak256("message_id");
        
        vm.prank(user1);
        vm.expectRevert("Not authorized relayer");
        bridge.verifyTonMessage(
            messageHash,
            messageId,
            user1,
            tonRecipient,
            1 ether,
            testHashlock,
            block.timestamp + 2 hours
        );
    }
    
    function testVerifyTonMessageEvent() public {
        bytes32 messageHash = keccak256("test_message");
        bytes32 messageId = keccak256("message_id");
        
        vm.prank(relayer1);
        vm.expectEmit(true, true, false, true);
        emit TonMessageVerified(messageHash, relayer1, true);
        bridge.verifyTonMessage(
            messageHash,
            messageId,
            user1,
            tonRecipient,
            1 ether,
            testHashlock,
            block.timestamp + 2 hours
        );
    }
    
    // Test message replay protection
    function testMessageReplayProtection() public {
        bytes32 messageHash = keccak256("test_message");
        bytes32 messageId = keccak256("message_id");
        
        // First verification
        vm.prank(relayer1);
        bridge.verifyTonMessage(
            messageHash,
            messageId,
            user1,
            tonRecipient,
            1 ether,
            testHashlock,
            block.timestamp + 2 hours
        );
        
        // Try to verify same message again
        vm.prank(relayer2);
        vm.expectRevert("Message already processed");
        bridge.verifyTonMessage(
            messageHash,
            messageId,
            user1,
            tonRecipient,
            1 ether,
            testHashlock,
            block.timestamp + 2 hours
        );
    }
    
    // Test relayer confirmations
    function testRelayerConfirmations() public {
        bytes32 messageHash = keccak256("test_message");
        bytes32 messageId = keccak256("message_id");
        
        // First relayer verification
        vm.prank(relayer1);
        bridge.verifyTonMessage(
            messageHash,
            messageId,
            user1,
            tonRecipient,
            1 ether,
            testHashlock,
            block.timestamp + 2 hours
        );
        
        // Check confirmations
        assertEq(bridge.messageConfirmations(messageHash), 1);
        assertFalse(bridge.hasSufficientConfirmations(messageHash));
        
        // Second relayer verification
        vm.prank(relayer2);
        bridge.verifyTonMessage(
            messageHash,
            messageId,
            user1,
            tonRecipient,
            1 ether,
            testHashlock,
            block.timestamp + 2 hours
        );
        
        // Check sufficient confirmations
        assertEq(bridge.messageConfirmations(messageHash), 2);
        assertTrue(bridge.hasSufficientConfirmations(messageHash));
    }
    
    // Test getter functions
    function testGetOrderInfo() public {
        // Create escrow first
        uint256 amount = 1 ether;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.prank(user1);
        bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        );
        
        EthereumTonBridge.EscrowOrder memory order = bridge.getOrderInfo(orderId);
        assertEq(order.sender, user1);
        assertEq(order.tonRecipient, tonRecipient);
        assertEq(order.amount, amount);
        assertEq(order.token, address(0));
        assertEq(order.hashlock, testHashlock);
        assertEq(order.timelock, timelock);
        assertEq(uint256(order.status), 0);
    }
    
    function testGetOrderInfoNotExists() public {
        EthereumTonBridge.EscrowOrder memory order = bridge.getOrderInfo(orderId);
        assertEq(order.sender, address(0));
        assertEq(order.amount, 0);
    }
    
    // Test constants
    function testConstants() public {
        assertEq(bridge.MIN_CONFIRMATIONS(), 2);
        assertEq(bridge.MAX_TIMELOCK(), 7 days);
        assertEq(bridge.MIN_TIMELOCK(), 1 hours);
    }
    
    // Integration tests
    function testCompleteCrossChainFlow() public {
        // 1. Create ETH escrow on Ethereum
        uint256 amount = 1 ether;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.prank(user1);
        bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        );
        
        // 2. Verify order creation
        EthereumTonBridge.EscrowOrder memory order = bridge.orders(orderId);
        assertEq(order.sender, user1);
        assertEq(uint256(order.status), 0);
        
        // 3. Simulate TON side fulfillment
        vm.prank(relayer1);
        bridge.fulfillFromTon(
            orderId,
            testSecret,
            user2
        );
        
        // 4. Verify fulfillment
        order = bridge.orders(orderId);
        assertEq(uint256(order.status), 1);
        assertEq(order.secret, testSecret);
        
        // 5. Verify funds transferred
        uint256 user2Balance = user2.balance;
        assertGt(user2Balance, 0);
    }
    
    function testCompleteTokenCrossChainFlow() public {
        // 1. Create token escrow on Ethereum
        uint256 amount = 100e18;
        uint256 timelock = block.timestamp + 2 hours;
        
        vm.startPrank(user1);
        mockToken.approve(address(bridge), amount);
        bridge.createTonEscrow(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(mockToken)
        );
        vm.stopPrank();
        
        // 2. Verify order creation
        EthereumTonBridge.EscrowOrder memory order = bridge.orders(orderId);
        assertEq(order.token, address(mockToken));
        assertEq(order.amount, amount);
        
        // 3. Simulate TON side fulfillment
        vm.prank(relayer1);
        bridge.fulfillFromTon(
            orderId,
            testSecret,
            user2
        );
        
        // 4. Verify fulfillment
        order = bridge.orders(orderId);
        assertEq(uint256(order.status), 1);
        
        // 5. Verify tokens transferred
        uint256 user2TokenBalance = mockToken.balanceOf(user2);
        assertEq(user2TokenBalance, amount);
    }
    
    // Fuzz tests
    function testFuzzCreateEscrow(uint256 amount, uint256 timelockOffset) public {
        vm.assume(amount > 0 && amount <= 100 ether);
        vm.assume(timelockOffset >= 3600 && timelockOffset <= 604800); // 1 hour to 1 week
        
        uint256 timelock = block.timestamp + timelockOffset;
        
        vm.deal(user1, amount);
        vm.prank(user1);
        
        try bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        ) {
            EthereumTonBridge.EscrowOrder memory order = bridge.orders(orderId);
            assertEq(order.amount, amount);
            assertEq(order.timelock, timelock);
        } catch {
            // Some combinations might fail due to validation
        }
    }
    
    // Gas optimization tests
    function testGasOptimization() public {
        uint256 amount = 1 ether;
        uint256 timelock = block.timestamp + 2 hours;
        
        uint256 gasBefore = gasleft();
        
        vm.prank(user1);
        bridge.createTonEscrow{value: amount}(
            orderId,
            tonRecipient,
            amount,
            testHashlock,
            timelock,
            address(0)
        );
        
        uint256 gasUsed = gasBefore - gasleft();
        console2.log("Gas used for escrow creation:", gasUsed);
        
        // Should be reasonable gas usage
        assertLt(gasUsed, 200000);
    }
} 