// SPDX-License-Identifier: MIT
pragma solidity ^0.8.23;

import {Test, console2} from "forge-std/Test.sol";
import {SecurityUtils} from "../src/SecurityUtils.sol";

contract SecurityUtilsTest is Test {
    SecurityUtils public securityUtils;
    
    address public owner;
    address public user1;
    address public user2;
    address public relayer1;
    address public relayer2;
    
    bytes32 public testSecret;
    bytes32 public testHashlock;
    bytes32 public messageHash;
    
    event HashlockGenerated(bytes32 indexed hashlock, address indexed generator);
    event SecretVerified(bytes32 indexed hashlock, bytes32 secret, address indexed verifier);
    event MessageReplayProtected(bytes32 indexed messageHash, address indexed sender);
    event RelayerConfirmation(bytes32 indexed messageHash, address indexed relayer);
    
    function setUp() public {
        owner = makeAddr("owner");
        user1 = makeAddr("user1");
        user2 = makeAddr("user2");
        relayer1 = makeAddr("relayer1");
        relayer2 = makeAddr("relayer2");
        
        vm.prank(owner);
        securityUtils = new SecurityUtils(owner);
        
        // Generate test data
        testSecret = keccak256("test_secret_123");
        testHashlock = keccak256(abi.encodePacked(testSecret));
        messageHash = keccak256("test_message");
    }
    
    // Test hashlock generation
    function testGenerateHashlock() public {
        vm.prank(user1);
        bytes32 generatedHashlock = securityUtils.generateHashlock(testSecret);
        
        assertEq(generatedHashlock, testHashlock);
    }
    
    function testGenerateHashlockWithZeroSecret() public {
        vm.prank(user1);
        vm.expectRevert("Invalid secret");
        securityUtils.generateHashlock(bytes32(0));
    }
    
    function testGenerateHashlockEvent() public {
        vm.prank(user1);
        vm.expectEmit(true, true, false, true);
        emit HashlockGenerated(testHashlock, user1);
        securityUtils.generateHashlock(testSecret);
    }
    
    // Test secret verification
    function testVerifySecretValid() public {
        vm.prank(user1);
        bool isValid = securityUtils.verifySecret(testSecret, testHashlock);
        
        assertTrue(isValid);
    }
    
    function testVerifySecretInvalid() public {
        bytes32 wrongSecret = keccak256("wrong_secret");
        vm.prank(user1);
        bool isValid = securityUtils.verifySecret(wrongSecret, testHashlock);
        
        assertFalse(isValid);
    }
    
    function testVerifySecretWithZeroSecret() public {
        vm.prank(user1);
        vm.expectRevert("Invalid secret");
        securityUtils.verifySecret(bytes32(0), testHashlock);
    }
    
    function testVerifySecretEvent() public {
        vm.prank(user1);
        vm.expectEmit(true, false, false, true);
        emit SecretVerified(testHashlock, testSecret, user1);
        securityUtils.verifySecret(testSecret, testHashlock);
    }
    
    // Test timelock validation
    function testValidateTimelockValid() public {
        uint256 validTimelock = block.timestamp + 2 hours;
        bool isValid = securityUtils.validateTimelock(validTimelock);
        
        assertTrue(isValid);
    }
    
    function testValidateTimelockTooShort() public {
        uint256 shortTimelock = block.timestamp + 30 minutes;
        bool isValid = securityUtils.validateTimelock(shortTimelock);
        
        assertFalse(isValid);
    }
    
    function testValidateTimelockTooLong() public {
        uint256 longTimelock = block.timestamp + 8 days;
        bool isValid = securityUtils.validateTimelock(longTimelock);
        
        assertFalse(isValid);
    }
    
    function testIsTimelockExpiredNotExpired() public {
        uint256 futureTimelock = block.timestamp + 1 hours;
        bool isExpired = securityUtils.isTimelockExpired(futureTimelock);
        
        assertFalse(isExpired);
    }
    
    function testIsTimelockExpiredExpired() public {
        uint256 pastTimelock = block.timestamp - 1 hours;
        bool isExpired = securityUtils.isTimelockExpired(pastTimelock);
        
        assertTrue(isExpired);
    }
    
    function testGetRemainingTime() public {
        uint256 timelock = block.timestamp + 3600; // 1 hour
        uint256 remaining = securityUtils.getRemainingTime(timelock);
        
        assertApproxEqRel(remaining, 3600, 0.01); // Allow 1% tolerance for block time
    }
    
    function testGetRemainingTimeExpired() public {
        uint256 timelock = block.timestamp - 3600; // 1 hour ago
        uint256 remaining = securityUtils.getRemainingTime(timelock);
        
        assertEq(remaining, 0);
    }
    
    // Test security parameters creation
    function testCreateSecurityParams() public {
        uint256 timelockDuration = 2 hours;
        SecurityUtils.SecurityParams memory params = securityUtils.createSecurityParams(
            testSecret, 
            timelockDuration
        );
        
        assertEq(params.hashlock, testHashlock);
        assertEq(params.timelock, block.timestamp + timelockDuration);
        assertEq(params.createdAt, block.timestamp);
        assertTrue(params.isValid);
    }
    
    function testCreateSecurityParamsInvalidTimelock() public {
        uint256 shortTimelock = 30 minutes;
        vm.expectRevert("Timelock too short");
        securityUtils.createSecurityParams(testSecret, shortTimelock);
    }
    
    // Test message replay protection
    function testProtectMessageReplay() public {
        vm.prank(user1);
        bool success = securityUtils.protectMessageReplay(messageHash);
        
        assertTrue(success);
        assertTrue(securityUtils.processedMessages(messageHash));
    }
    
    function testProtectMessageReplayDuplicate() public {
        vm.prank(user1);
        securityUtils.protectMessageReplay(messageHash);
        
        vm.prank(user2);
        vm.expectRevert("Message already processed");
        securityUtils.protectMessageReplay(messageHash);
    }
    
    function testProtectMessageReplayEvent() public {
        vm.prank(user1);
        vm.expectEmit(true, true, false, true);
        emit MessageReplayProtected(messageHash, user1);
        securityUtils.protectMessageReplay(messageHash);
    }
    
    // Test relayer confirmations
    function testAddRelayerConfirmation() public {
        vm.prank(relayer1);
        uint256 confirmations = securityUtils.addRelayerConfirmation(messageHash, relayer1);
        
        assertEq(confirmations, 1);
        assertTrue(securityUtils.relayerConfirmations(messageHash, relayer1));
    }
    
    function testAddRelayerConfirmationDuplicate() public {
        vm.prank(relayer1);
        securityUtils.addRelayerConfirmation(messageHash, relayer1);
        
        vm.prank(relayer1);
        vm.expectRevert("Already confirmed by this relayer");
        securityUtils.addRelayerConfirmation(messageHash, relayer1);
    }
    
    function testAddRelayerConfirmationMultiple() public {
        vm.prank(relayer1);
        uint256 confirmations1 = securityUtils.addRelayerConfirmation(messageHash, relayer1);
        assertEq(confirmations1, 1);
        
        vm.prank(relayer2);
        uint256 confirmations2 = securityUtils.addRelayerConfirmation(messageHash, relayer2);
        assertEq(confirmations2, 2);
    }
    
    function testAddRelayerConfirmationEvent() public {
        vm.prank(relayer1);
        vm.expectEmit(true, true, false, true);
        emit RelayerConfirmation(messageHash, relayer1);
        securityUtils.addRelayerConfirmation(messageHash, relayer1);
    }
    
    function testHasSufficientConfirmations() public {
        // Add one confirmation
        vm.prank(relayer1);
        securityUtils.addRelayerConfirmation(messageHash, relayer1);
        
        bool hasSufficient = securityUtils.hasSufficientConfirmations(messageHash);
        assertFalse(hasSufficient);
        
        // Add second confirmation
        vm.prank(relayer2);
        securityUtils.addRelayerConfirmation(messageHash, relayer2);
        
        hasSufficient = securityUtils.hasSufficientConfirmations(messageHash);
        assertTrue(hasSufficient);
    }
    
    // Test message security info
    function testGetMessageSecurity() public {
        vm.prank(user1);
        securityUtils.protectMessageReplay(messageHash);
        
        vm.prank(relayer1);
        securityUtils.addRelayerConfirmation(messageHash, relayer1);
        
        SecurityUtils.MessageSecurity memory security = securityUtils.getMessageSecurity(messageHash);
        
        assertEq(security.messageHash, messageHash);
        assertEq(security.timestamp, block.timestamp);
        assertEq(security.confirmations, 1);
        assertTrue(security.processed);
    }
    
    // Test emergency functions
    function testEmergencyResetMessage() public {
        vm.prank(user1);
        securityUtils.protectMessageReplay(messageHash);
        
        vm.prank(relayer1);
        securityUtils.addRelayerConfirmation(messageHash, relayer1);
        
        // Reset as owner
        vm.prank(owner);
        securityUtils.emergencyResetMessage(messageHash);
        
        // Verify reset
        assertFalse(securityUtils.processedMessages(messageHash));
        assertEq(securityUtils.messageConfirmations(messageHash), 0);
    }
    
    function testEmergencyResetMessageNotOwner() public {
        vm.prank(user1);
        vm.expectRevert();
        securityUtils.emergencyResetMessage(messageHash);
    }
    
    // Test constants
    function testConstants() public {
        assertEq(securityUtils.MIN_TIMELOCK(), 1 hours);
        assertEq(securityUtils.MAX_TIMELOCK(), 7 days);
        assertEq(securityUtils.SECRET_LENGTH(), 32);
        assertEq(securityUtils.MIN_CONFIRMATIONS(), 2);
    }
    
    // Integration tests
    function testCompleteAtomicSwapFlow() public {
        // 1. Generate hashlock
        vm.prank(user1);
        bytes32 generatedHashlock = securityUtils.generateHashlock(testSecret);
        
        // 2. Create security parameters
        SecurityUtils.SecurityParams memory params = securityUtils.createSecurityParams(
            testSecret, 
            2 hours
        );
        
        // 3. Protect message replay
        bytes32 swapMessageHash = keccak256(abi.encodePacked("swap", user1, user2));
        vm.prank(user1);
        securityUtils.protectMessageReplay(swapMessageHash);
        
        // 4. Add relayer confirmations
        vm.prank(relayer1);
        securityUtils.addRelayerConfirmation(swapMessageHash, relayer1);
        
        vm.prank(relayer2);
        securityUtils.addRelayerConfirmation(swapMessageHash, relayer2);
        
        // 5. Verify sufficient confirmations
        bool hasSufficient = securityUtils.hasSufficientConfirmations(swapMessageHash);
        assertTrue(hasSufficient);
        
        // 6. Verify secret
        vm.prank(user2);
        bool isValid = securityUtils.verifySecret(testSecret, generatedHashlock);
        assertTrue(isValid);
    }
    
    // Fuzz tests
    function testFuzzHashlockGeneration(bytes32 secret) public {
        vm.assume(secret != bytes32(0));
        
        vm.prank(user1);
        bytes32 generatedHashlock = securityUtils.generateHashlock(secret);
        
        // Verify the generated hashlock matches expected
        bytes32 expectedHashlock = keccak256(abi.encodePacked(secret));
        assertEq(generatedHashlock, expectedHashlock);
    }
    
    function testFuzzTimelockValidation(uint256 timelock) public {
        bool isValid = securityUtils.validateTimelock(timelock);
        
        bool expectedValid = timelock >= block.timestamp + securityUtils.MIN_TIMELOCK() && 
                            timelock <= block.timestamp + securityUtils.MAX_TIMELOCK();
        
        assertEq(isValid, expectedValid);
    }
    
    // Gas optimization tests
    function testGasOptimization() public {
        uint256 gasBefore = gasleft();
        
        vm.prank(user1);
        securityUtils.generateHashlock(testSecret);
        
        uint256 gasUsed = gasBefore - gasleft();
        console2.log("Gas used for hashlock generation:", gasUsed);
        
        // Should be reasonable gas usage
        assertLt(gasUsed, 50000);
    }
} 